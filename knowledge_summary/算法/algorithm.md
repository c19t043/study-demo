# algorithm

基于比较的排序

## 时间复杂度

常数时间的操作：一个操作如果和数据量没有关系，
每次都是固定时间内完成的操作，叫做常数操作

时间复杂度为一个算法流程中，常数操作数量的指标。
常用O(读作big O)来表示。具体来说，在常数操作数量的表达式中，
只要高阶项，不要低阶项，也不要高阶项系数,
剩下的部分如果记为f(N)，那么时间复杂度为O(f(N))

评价一个算法流程的好坏，先看时间复杂度的指标，
然后再分析不同数据样本下的实际运行时间，
也即使常数项时间。

### 时间复杂度例子

一个简单的理解时间复杂度的例子

一个有序数组A,另一个无序数组B，请打印B中的所有不在A中的数，
A数组长度为N，B数组长度为M

算法流程1：对于数组B中的每一个数，都在A中通过便利的方式找一下

算法流程2：对于数组B中的每一个数，都在A中通过二分的方式找一下；

算法流程3：先把数组B排序，然后用类似外排的方式打印所有在A中出现的数

三个流程，三种时间复杂度的表达式

如何分析好坏

算法流程1：

M*N

O(M*N)

算法流程2：

M*lgN

O(M*lgN)

log2

算法流程3：

排序 O(M*lgM)

外排 O(N+M)

样本量不确定，
时间复杂度：O(M*lgM)+O(N+M)

### 大O表示法

+ `O(1)`

f(1+2+3)

O(1)

+ `O(n)`

f(n+1)

f(2n+1)

+ `O(n^2)`

f(2n^2+1)

## 二分查找法

从一个有序数组A中，查找一个数B,
选择数组A中间位置的数C与数B比较，
如果数C大于数B，则说明，数B在数C的左侧部分，
如果数C小于数B，则说明，数B在数C的右侧部分，
如此反复，直到查找到数B，或数组B不在数组A中为止，

因每次从数组中间位置开始比较，每次排除一半选项，
得名二分查找法

时间复杂度为：lgN

## 外排

有两个有序数组A,B，长度为M,N,从A数组中找到B数组相同的元素

有a,b两指针，分别从数组A,B左侧取数比较，
如果指针a，对应的数组A[a],小于数组B[b]，则指针a向前移动,
如果A[a]大于B[b],则指针b向前移动，
如果A[a]等于B[b]，则打印B[b]，指针b向前移动，
指针a,b有达到数组长度为止

时间复杂度：M+N